# 贪心算法二

### [加油站](https://leetcode-cn.com/problems/gas-station/)

> 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
>
> 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
>
> 说明: 
>
> - 如果题目有解，该答案即为唯一答案。
> - 输入数组均为非空数组，且长度相同。
> - 输入数组中的元素均为非负数。
>
>  输入:
>
> - gas = [1,2,3,4,5]
> - cost = [3,4,5,1,2]
>
> 输出: 3 
>
> 解释:
>
> - 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> - 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> - 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> - 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> - 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> - 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> - 因此，3 可为起始索引。

```js
var canCompleteCircuit = function(gas, cost) {
  let totalSum = 0;
  let curSum = 0;
  let index= 0
  for(let i = 0;i<gas.length;i++){
      // 累加行程油量
      totalSum+=(gas[i]-cost[i])
     // 累加为正的油量
      curSum+=(gas[i]-cost[i])
     // 如果前面的油耗不够行程触发，则重置，假设下个为起点，并重新累加
      if(curSum<0){
          index = i+1
          curSum = 0
      }
  }
  // 不能走完整个行程
  if(totalSum<0) return -1
  return index
};
```

### [分发糖果](https://leetcode-cn.com/problems/candy/)

> 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
>
> 你需要按照以下要求，帮助老师给这些孩子分发糖果：
>
> - 每个孩子至少分配到 1 个糖果。
> - 相邻的孩子中，评分高的孩子必须获得更多的糖果。
>
> 那么这样下来，老师至少需要准备多少颗糖果呢？
>
> 示例 1:
>
> - 输入: [1,0,2]
> - 输出: 5
> - 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。

```js
var candy = function(ratings) {
 // 先把糖果默认分配为1
 const swips = new Array(ratings.length).fill(1);

  // 右边比左边大，则右边分配糖果比左边+1
  for(let i = 1;i < ratings.length;i++){
    if(ratings[i] > ratings[i - 1]){
      swips[i] = swips[i - 1] + 1;
    }
  }
	// 如果左边比右边评分高，则左边分配糖果比右边大（如果已经大的，则不变，否则+1）！！！比较难理解至少准备多少糖果，最小原则
  for(let i = ratings.length - 2;i >= 0;i--){
    if(ratings[i] > ratings[i + 1]){
      // 为什么要是max? 因为要保证原数据的大小关系，而且还要保证左边的一定要大于右边的
      swips[i] = Math.max(
        swips[i], swips[i + 1] + 1
      );
    }
  }
	// [1,3,4,5,2]
  // [1,1,1,1,1]
  // [1,2,3,4,1]
  // [1,2,3,4,1]
  return swips.reduce((prev, next) => prev + next);
};
```

### [根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

> 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
>
> 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
>
> 示例 1：
>
> - 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
> - 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
> - 解释：
>   - 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
>   - 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
>   - 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
>   - 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
>   - 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
>   - 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
>   - 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

```js
var reconstructQueue = function(people) {
  // 按身高从高多低排列，人数从低到高
  people.sort((a, b) => {
    if(a[0] === b[0]){
      return a[1] - b[1];
    }else{
      return b[0] - a[0];
    }
  });
  const quene = [];
  // 按人数插入队列
  for(let i = 0;i < people.length;i++){
    quene.splice(people[i][1], 0, people[i]);
  }
  return quene;
};
```

